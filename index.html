<!DOCTYPE html>
<head>
<style>
    path {
  fill: none;
  stroke: #666;
  stroke-width: 2px;
}
</style>
<meta charset="utf-8">
<title>Million Song Dataset</title>
</head>
    <!-- Add a search bar/dropdown to select artist -->
<body>
<script type="text/javascript" src="../lib/d3.v5.min.js"></script>
<script>
    var edgesFilePath = 'data/edges.csv';
    var nodesFilePath = 'data/nodes.csv';
    
    Promise.all([
        d3.dsv(",", edgesFilePath, function(edge) {
            return {
                source_artist_id: edge.source_artist_id,
                target_artist_id: edge.target_artist_id,
                priority: parseInt(edge.priority)
            };
        }),
        d3.dsv(",", nodesFilePath, (node) => {
            return {
                artist_id: node.artist_id, 
                artist_name: node.artist_name, 
                avg_duration: parseFloat(node.avg_duration), 
                avg_familiarity: parseFloat(node.avg_familiarity), 
                avg_hotness: parseFloat(node.avg_hotttnesss), 
                total_tracks: parseInt(node.total_tracks)
            };
        })
    ]).then(allData => {
        let edges = allData[0];
        let nodes = allData[1];
        console.log(edges.length, nodes.length);

        // SVG Dimensions
        var width = 1080;
        var height = 720;
        var margins = { left: 50, right: 50, top: 30, bottom: 30 };

        var svg = d3.select("body").append("svg")
                    .attr("width", width)
                    .attr("height", height);
        var graph = svg.append("g")
                    .attr("width", width - margins.left - margins.right)
                    .attr("height", height - margins.top - margins.bottom)
                    .attr("transform", "translate( " + margins.left + ", "+ margins.top + ")")

        // Display initial nodes of top artists to select from

        // Show initial network of artist based on selected artist (How many neighbors to show in the beginning?)
        var selectedArtist = nodes[0];

        var artistNetwork = getArtistNetwork(edges, selectedArtist['artist_id']); // default 20 similar artists
        console.log('selected artist is: ', selectedArtist);
        console.log('similar artists are: ', artistNetwork);

        let allNodes = nodes.filter(node => {
            return artistNetwork.some(edge => edge['target_artist_id'] === node['artist_id']);
        });
        allNodes.push(selectedArtist);
        console.log('all nodes in network: ', allNodes);


        var node = graph
                    .selectAll(".node")
                    .data(allNodes)
                    .enter()
                    .append("g")
                    .attr("class", "node");

        var circles = node.append("circle")
                        .attr("cx", (d) => {
                            d.x = Math.random() * (width - margins.left - margins.right); 
                            return d.x; 
                        })
                        .attr("cy", (d) => {
                            d.y = Math.random() * (height - margins.top - margins.bottom);
                            return d.y;
                        })
                        .attr("r", 25)
                        .attr("fill", "#77a2c9");

        node.append("text")
            .attr("stroke", "black")
            .attr("font-size", "15px")
            .attr("x", function(d) { return d.x; })
            .attr("y", function(d) { return d.y - 30; })
            .attr("text-anchor", "middle")
            .text(function(d) {
                return d['artist_name'];
        });

        var path = graph
                    .selectAll("path")
                    .data(artistNetwork)
                    .enter()
                    .append("path");

        path.attr("d", function(d) {
            var source = allNodes.filter(node => d['source_artist_id'] === node['artist_id'])[0];
            var target = allNodes.filter(node => d['target_artist_id'] === node['artist_id'])[0];
            var line =  "M" + source.x + "," + source.y + "L" + target.x + "," + target.y;
            return line;
      });
        
        //Dynamic node size based on number of songs
        
        // Dynamic color of nodes (genre/pin?)

        // Dynamic color and thickness of edges (based on collaboration?)

        // Any other styling for selected node

    }).catch(error => {
        
    });

    /**
     * To get the similar artist network from list of edges
     * @param edges: array of all edges
     * @param artist_id: id of the artist to find the network for
     * @param count: number of similar artists to return sorted by priority
     */
    function getArtistNetwork(edges, artist_id, count = 20) {
        return edges.filter(edge => edge['source_artist_id'] === artist_id)
                .sort((edge1, edge2) => edge1['priority'] - edge2['priority'])
                .slice(0, count);
    }
    
</script>
</body>
</html>
